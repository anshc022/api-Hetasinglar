# GitHub Actions workflow for automatic deployment to AWS EC2
name: Deploy to AWS EC2

# Trigger workflow on push to main branch
on:
  push:
    branches: [ main ]
  workflow_dispatch: # Allow manual trigger


env:
  PROJECT_PATH: ~/apps/api-Hetasinglar

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Create Environment File
      - name: Create Environment File
        run: |
          echo "Creating .env file with production secrets..."
          cat > .env << EOF
          # Database Configuration
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          
          # Authentication
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          
          # Server Configuration
          PORT=5000
          NODE_ENV=production
          
          # Frontend Configuration
          FRONTEND_URL=https://hetasinglar.vercel.app
          
          # CORS Configuration
          ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS || 'https://hetasinglar.vercel.app' }}
          EOF

      # Step 3: Copy project files to EC2 server
      - name: Copy Files to EC2
        uses: appleboy/scp-action@v0.1.4
        with:
          # EC2 connection details from GitHub Secrets
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          
          # Source and destination paths
          source: "."
          target: ${{ env.PROJECT_PATH }}
          
          # Overwrite existing files and remove extra files
          overwrite: true
          rm: true

      # Step 4: Deploy application using Docker Compose
      - name: Deploy Application
        uses: appleboy/ssh-action@v1.0.3
        with:
          # EC2 connection details
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          
          # Deployment commands
          script: |
            echo "Starting deployment process..."
            
            # Navigate to project directory
            cd ${{ env.PROJECT_PATH }}
            
            # Show current directory for debugging
            echo "Current directory: $(pwd)"
            
            # Stop any existing Node.js processes more gracefully
            echo "Stopping existing Node.js processes..."
            if command -v pm2 >/dev/null 2>&1; then
              echo "Stopping PM2 processes..."
              pm2 stop all || true
              pm2 delete all || true
            fi
            
            # Kill any remaining node processes gracefully
            if pgrep -f "node server.js" > /dev/null; then
              echo "Stopping existing Node.js server..."
              pkill -TERM -f "node server.js" || true
              sleep 3
              pkill -KILL -f "node server.js" || true
            fi
            
            # Install dependencies
            echo "Installing dependencies..."
            npm install --production --silent
            
            # Create environment file with production values
            echo "Creating production environment file..."
            cat > .env << 'EOF'
            PORT=5000
            NODE_ENV=production
            FRONTEND_URL=https://hetasinglar.vercel.app
            ALLOWED_ORIGINS=https://hetasinglar.vercel.app,https://hetasinglar.onrender.com,https://www.hetasinglar.onrender.com
            MONGODB_URI=${{ secrets.MONGODB_URI }}
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            EOF
            
            # Start the application using PM2 (if available) or directly with Node.js
            echo "Starting application..."
            if command -v pm2 >/dev/null 2>&1; then
              echo "Using PM2 to start application..."
              pm2 start server.js --name "hetasinglar-api" --max-memory-restart 1G --time
              pm2 save
              echo "PM2 status:"
              pm2 status
            else
              echo "Starting with Node.js directly..."
              nohup node server.js > app.log 2>&1 &
              APP_PID=$!
              echo "Application started with PID: $APP_PID"
              echo $APP_PID > app.pid
            fi
            
            # Wait for application to start
            echo "Waiting for application to start..."
            sleep 10
            
            # Verify application is responding
            echo "Verifying deployment..."
            for i in {1..5}; do
              if curl -f http://localhost:5000/api/health > /dev/null 2>&1; then
                echo "‚úÖ Deployment successful! Application is responding."
                echo "üìä Application status check:"
                curl -s http://localhost:5000/api/health
                break
              else
                echo "Attempt $i: Application not responding yet, waiting..."
                sleep 5
              fi
            done
            
            # Final verification
            if ! curl -f http://localhost:5000/api/health > /dev/null 2>&1; then
              echo "‚ö†Ô∏è  Warning: Application health check failed. Checking logs..."
              if [ -f "app.log" ]; then
                echo "Recent application logs:"
                tail -20 app.log
              fi
              if command -v pm2 >/dev/null 2>&1; then
                echo "PM2 logs:"
                pm2 logs --lines 10 --nostream
              fi
              exit 1
            fi
            
            # Show running processes
            echo "Running Node.js processes:"
            ps aux | grep node | grep -v grep || echo "No Node.js processes found"

      # Step 5: Deployment notification (optional)
      - name: Deployment Status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "üöÄ Deployment completed successfully!"
          else
            echo "‚ùå Deployment failed. Check the logs above."
            exit 1
          fi